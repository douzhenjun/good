// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.23.0
// 	protoc        v3.13.0
// source: api.proto

package api

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type TASKTYPE int32

const (
	TASKTYPE_TASKCMDLINE       TASKTYPE = 0
	TASKTYPE_TASKCMDSCRIPT     TASKTYPE = 1
	TASKTYPE_TASKDEPLOYAGENT   TASKTYPE = 2
	TASKTYPE_TASKSCPFILE       TASKTYPE = 3
	TASKTYPE_TASKRECURRING     TASKTYPE = 4
	TASKTYPE_TASKVERIFYCLUSTER TASKTYPE = 5
	TASKTYPE_TASKBDEPLOYAGENTS TASKTYPE = 6
	TASKTYPE_TASKWORKFLOW      TASKTYPE = 7
)

// Enum value maps for TASKTYPE.
var (
	TASKTYPE_name = map[int32]string{
		0: "TASKCMDLINE",
		1: "TASKCMDSCRIPT",
		2: "TASKDEPLOYAGENT",
		3: "TASKSCPFILE",
		4: "TASKRECURRING",
		5: "TASKVERIFYCLUSTER",
		6: "TASKBDEPLOYAGENTS",
		7: "TASKWORKFLOW",
	}
	TASKTYPE_value = map[string]int32{
		"TASKCMDLINE":       0,
		"TASKCMDSCRIPT":     1,
		"TASKDEPLOYAGENT":   2,
		"TASKSCPFILE":       3,
		"TASKRECURRING":     4,
		"TASKVERIFYCLUSTER": 5,
		"TASKBDEPLOYAGENTS": 6,
		"TASKWORKFLOW":      7,
	}
)

func (x TASKTYPE) Enum() *TASKTYPE {
	p := new(TASKTYPE)
	*p = x
	return p
}

func (x TASKTYPE) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TASKTYPE) Descriptor() protoreflect.EnumDescriptor {
	return file_api_proto_enumTypes[0].Descriptor()
}

func (TASKTYPE) Type() protoreflect.EnumType {
	return &file_api_proto_enumTypes[0]
}

func (x TASKTYPE) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TASKTYPE.Descriptor instead.
func (TASKTYPE) EnumDescriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{0}
}

type COPYDIRECTION int32

const (
	COPYDIRECTION_COPYTO   COPYDIRECTION = 0
	COPYDIRECTION_COPYFROM COPYDIRECTION = 1
)

// Enum value maps for COPYDIRECTION.
var (
	COPYDIRECTION_name = map[int32]string{
		0: "COPYTO",
		1: "COPYFROM",
	}
	COPYDIRECTION_value = map[string]int32{
		"COPYTO":   0,
		"COPYFROM": 1,
	}
)

func (x COPYDIRECTION) Enum() *COPYDIRECTION {
	p := new(COPYDIRECTION)
	*p = x
	return p
}

func (x COPYDIRECTION) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (COPYDIRECTION) Descriptor() protoreflect.EnumDescriptor {
	return file_api_proto_enumTypes[1].Descriptor()
}

func (COPYDIRECTION) Type() protoreflect.EnumType {
	return &file_api_proto_enumTypes[1]
}

func (x COPYDIRECTION) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use COPYDIRECTION.Descriptor instead.
func (COPYDIRECTION) EnumDescriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{1}
}

type STATE int32

const (
	STATE_UNKNOWN     STATE = 0
	STATE_PENDING     STATE = 1
	STATE_RUNNING     STATE = 2
	STATE_COMPLETE    STATE = 3
	STATE_STOPPED     STATE = 4
	STATE_TIMEOUT     STATE = 6
	STATE_SSHNETFAIL  STATE = 7
	STATE_TASKFAIL    STATE = 8
	STATE_TASKNOEXIST STATE = 9
	STATE_WAITING     STATE = 10
)

// Enum value maps for STATE.
var (
	STATE_name = map[int32]string{
		0:  "UNKNOWN",
		1:  "PENDING",
		2:  "RUNNING",
		3:  "COMPLETE",
		4:  "STOPPED",
		6:  "TIMEOUT",
		7:  "SSHNETFAIL",
		8:  "TASKFAIL",
		9:  "TASKNOEXIST",
		10: "WAITING",
	}
	STATE_value = map[string]int32{
		"UNKNOWN":     0,
		"PENDING":     1,
		"RUNNING":     2,
		"COMPLETE":    3,
		"STOPPED":     4,
		"TIMEOUT":     6,
		"SSHNETFAIL":  7,
		"TASKFAIL":    8,
		"TASKNOEXIST": 9,
		"WAITING":     10,
	}
)

func (x STATE) Enum() *STATE {
	p := new(STATE)
	*p = x
	return p
}

func (x STATE) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (STATE) Descriptor() protoreflect.EnumDescriptor {
	return file_api_proto_enumTypes[2].Descriptor()
}

func (STATE) Type() protoreflect.EnumType {
	return &file_api_proto_enumTypes[2]
}

func (x STATE) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use STATE.Descriptor instead.
func (STATE) EnumDescriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{2}
}

type RETURNLINEMSGTYPE int32

const (
	RETURNLINEMSGTYPE_STDOUT      RETURNLINEMSGTYPE = 0
	RETURNLINEMSGTYPE_STDERR      RETURNLINEMSGTYPE = 1
	RETURNLINEMSGTYPE_TASKSTATE   RETURNLINEMSGTYPE = 2
	RETURNLINEMSGTYPE_EXITCODE    RETURNLINEMSGTYPE = 3
	RETURNLINEMSGTYPE_TASKERR     RETURNLINEMSGTYPE = 4
	RETURNLINEMSGTYPE_EOF         RETURNLINEMSGTYPE = 5
	RETURNLINEMSGTYPE_VERIFYITEM  RETURNLINEMSGTYPE = 6
	RETURNLINEMSGTYPE_BATCHDEPLOY RETURNLINEMSGTYPE = 7
	RETURNLINEMSGTYPE_WORKFLOW    RETURNLINEMSGTYPE = 8
)

// Enum value maps for RETURNLINEMSGTYPE.
var (
	RETURNLINEMSGTYPE_name = map[int32]string{
		0: "STDOUT",
		1: "STDERR",
		2: "TASKSTATE",
		3: "EXITCODE",
		4: "TASKERR",
		5: "EOF",
		6: "VERIFYITEM",
		7: "BATCHDEPLOY",
		8: "WORKFLOW",
	}
	RETURNLINEMSGTYPE_value = map[string]int32{
		"STDOUT":      0,
		"STDERR":      1,
		"TASKSTATE":   2,
		"EXITCODE":    3,
		"TASKERR":     4,
		"EOF":         5,
		"VERIFYITEM":  6,
		"BATCHDEPLOY": 7,
		"WORKFLOW":    8,
	}
)

func (x RETURNLINEMSGTYPE) Enum() *RETURNLINEMSGTYPE {
	p := new(RETURNLINEMSGTYPE)
	*p = x
	return p
}

func (x RETURNLINEMSGTYPE) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RETURNLINEMSGTYPE) Descriptor() protoreflect.EnumDescriptor {
	return file_api_proto_enumTypes[3].Descriptor()
}

func (RETURNLINEMSGTYPE) Type() protoreflect.EnumType {
	return &file_api_proto_enumTypes[3]
}

func (x RETURNLINEMSGTYPE) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RETURNLINEMSGTYPE.Descriptor instead.
func (RETURNLINEMSGTYPE) EnumDescriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{3}
}

type HTTPMETHOD int32

const (
	HTTPMETHOD_GET     HTTPMETHOD = 0
	HTTPMETHOD_POST    HTTPMETHOD = 1
	HTTPMETHOD_PUT     HTTPMETHOD = 2
	HTTPMETHOD_DELETE  HTTPMETHOD = 3
	HTTPMETHOD_OPTIONS HTTPMETHOD = 4
	HTTPMETHOD_HEAD    HTTPMETHOD = 5
	HTTPMETHOD_TRACE   HTTPMETHOD = 6
	HTTPMETHOD_CONNECT HTTPMETHOD = 7
)

// Enum value maps for HTTPMETHOD.
var (
	HTTPMETHOD_name = map[int32]string{
		0: "GET",
		1: "POST",
		2: "PUT",
		3: "DELETE",
		4: "OPTIONS",
		5: "HEAD",
		6: "TRACE",
		7: "CONNECT",
	}
	HTTPMETHOD_value = map[string]int32{
		"GET":     0,
		"POST":    1,
		"PUT":     2,
		"DELETE":  3,
		"OPTIONS": 4,
		"HEAD":    5,
		"TRACE":   6,
		"CONNECT": 7,
	}
)

func (x HTTPMETHOD) Enum() *HTTPMETHOD {
	p := new(HTTPMETHOD)
	*p = x
	return p
}

func (x HTTPMETHOD) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HTTPMETHOD) Descriptor() protoreflect.EnumDescriptor {
	return file_api_proto_enumTypes[4].Descriptor()
}

func (HTTPMETHOD) Type() protoreflect.EnumType {
	return &file_api_proto_enumTypes[4]
}

func (x HTTPMETHOD) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HTTPMETHOD.Descriptor instead.
func (HTTPMETHOD) EnumDescriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{4}
}

//Task of deploying agent. critical task, no timeout.
type TaskDeployAgent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	IPorHostName string   `protobuf:"bytes,1,opt,name=IPorHostName,proto3" json:"IPorHostName,omitempty"` //hostname or ip
	User         string   `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	Password     string   `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	Tags         []string `protobuf:"bytes,4,rep,name=Tags,proto3" json:"Tags,omitempty"`
	Port         int32    `protobuf:"varint,5,opt,name=Port,proto3" json:"Port,omitempty"` //default = common.PortOfSysSSH
}

func (x *TaskDeployAgent) Reset() {
	*x = TaskDeployAgent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TaskDeployAgent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskDeployAgent) ProtoMessage() {}

func (x *TaskDeployAgent) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskDeployAgent.ProtoReflect.Descriptor instead.
func (*TaskDeployAgent) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{0}
}

func (x *TaskDeployAgent) GetIPorHostName() string {
	if x != nil {
		return x.IPorHostName
	}
	return ""
}

func (x *TaskDeployAgent) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *TaskDeployAgent) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *TaskDeployAgent) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *TaskDeployAgent) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

type TaskCommandLine struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ExecHost string   `protobuf:"bytes,1,opt,name=ExecHost,proto3" json:"ExecHost,omitempty"`
	CmdLine  string   `protobuf:"bytes,2,opt,name=CmdLine,proto3" json:"CmdLine,omitempty"`
	Timeout  int64    `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Tags     []string `protobuf:"bytes,4,rep,name=Tags,proto3" json:"Tags,omitempty"`
	OSUser   string   `protobuf:"bytes,5,opt,name=OSUser,proto3" json:"OSUser,omitempty"`
}

func (x *TaskCommandLine) Reset() {
	*x = TaskCommandLine{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TaskCommandLine) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskCommandLine) ProtoMessage() {}

func (x *TaskCommandLine) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskCommandLine.ProtoReflect.Descriptor instead.
func (*TaskCommandLine) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{1}
}

func (x *TaskCommandLine) GetExecHost() string {
	if x != nil {
		return x.ExecHost
	}
	return ""
}

func (x *TaskCommandLine) GetCmdLine() string {
	if x != nil {
		return x.CmdLine
	}
	return ""
}

func (x *TaskCommandLine) GetTimeout() int64 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *TaskCommandLine) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *TaskCommandLine) GetOSUser() string {
	if x != nil {
		return x.OSUser
	}
	return ""
}

type CmdScript struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ID      string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Content string `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	Md5     string `protobuf:"bytes,3,opt,name=md5,proto3" json:"md5,omitempty"`
}

func (x *CmdScript) Reset() {
	*x = CmdScript{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CmdScript) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CmdScript) ProtoMessage() {}

func (x *CmdScript) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CmdScript.ProtoReflect.Descriptor instead.
func (*CmdScript) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{2}
}

func (x *CmdScript) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *CmdScript) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *CmdScript) GetMd5() string {
	if x != nil {
		return x.Md5
	}
	return ""
}

type TaskScriptOnHost struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ExecHost string   `protobuf:"bytes,1,opt,name=ExecHost,proto3" json:"ExecHost,omitempty"`
	ID       string   `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Timeout  int64    `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Md5      string   `protobuf:"bytes,4,opt,name=md5,proto3" json:"md5,omitempty"`
	Tags     []string `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty"`
	OSUser   string   `protobuf:"bytes,6,opt,name=OSUser,proto3" json:"OSUser,omitempty"`
}

func (x *TaskScriptOnHost) Reset() {
	*x = TaskScriptOnHost{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TaskScriptOnHost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskScriptOnHost) ProtoMessage() {}

func (x *TaskScriptOnHost) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskScriptOnHost.ProtoReflect.Descriptor instead.
func (*TaskScriptOnHost) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{3}
}

func (x *TaskScriptOnHost) GetExecHost() string {
	if x != nil {
		return x.ExecHost
	}
	return ""
}

func (x *TaskScriptOnHost) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *TaskScriptOnHost) GetTimeout() int64 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *TaskScriptOnHost) GetMd5() string {
	if x != nil {
		return x.Md5
	}
	return ""
}

func (x *TaskScriptOnHost) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *TaskScriptOnHost) GetOSUser() string {
	if x != nil {
		return x.OSUser
	}
	return ""
}

type TaskScpFile struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	CopyDirection COPYDIRECTION `protobuf:"varint,1,opt,name=CopyDirection,proto3,enum=api.COPYDIRECTION" json:"CopyDirection,omitempty"`
	RemoteHost    string        `protobuf:"bytes,2,opt,name=RemoteHost,proto3" json:"RemoteHost,omitempty"`
	SrcFile       string        `protobuf:"bytes,3,opt,name=SrcFile,proto3" json:"SrcFile,omitempty"`
	DstFile       string        `protobuf:"bytes,4,opt,name=DstFile,proto3" json:"DstFile,omitempty"`
	Timeout       int64         `protobuf:"varint,5,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Tags          []string      `protobuf:"bytes,6,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (x *TaskScpFile) Reset() {
	*x = TaskScpFile{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TaskScpFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskScpFile) ProtoMessage() {}

func (x *TaskScpFile) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskScpFile.ProtoReflect.Descriptor instead.
func (*TaskScpFile) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{4}
}

func (x *TaskScpFile) GetCopyDirection() COPYDIRECTION {
	if x != nil {
		return x.CopyDirection
	}
	return COPYDIRECTION_COPYTO
}

func (x *TaskScpFile) GetRemoteHost() string {
	if x != nil {
		return x.RemoteHost
	}
	return ""
}

func (x *TaskScpFile) GetSrcFile() string {
	if x != nil {
		return x.SrcFile
	}
	return ""
}

func (x *TaskScpFile) GetDstFile() string {
	if x != nil {
		return x.DstFile
	}
	return ""
}

func (x *TaskScpFile) GetTimeout() int64 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *TaskScpFile) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

type Empty struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() {
	*x = Empty{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Empty) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Empty) ProtoMessage() {}

func (x *Empty) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{5}
}

type Status struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ID        string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	State     STATE    `protobuf:"varint,2,opt,name=State,proto3,enum=api.STATE" json:"State,omitempty"`
	StartTime int64    `protobuf:"varint,3,opt,name=StartTime,proto3" json:"StartTime,omitempty"`
	StopTime  int64    `protobuf:"varint,4,opt,name=StopTime,proto3" json:"StopTime,omitempty"`
	Stdout    string   `protobuf:"bytes,5,opt,name=Stdout,proto3" json:"Stdout,omitempty"`
	Stderr    string   `protobuf:"bytes,6,opt,name=Stderr,proto3" json:"Stderr,omitempty"`
	ExitCode  int32    `protobuf:"varint,7,opt,name=ExitCode,proto3" json:"ExitCode,omitempty"`
	TaskErr   []string `protobuf:"bytes,8,rep,name=TaskErr,proto3" json:"TaskErr,omitempty"`
}

func (x *Status) Reset() {
	*x = Status{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Status) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Status) ProtoMessage() {}

func (x *Status) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Status.ProtoReflect.Descriptor instead.
func (*Status) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{6}
}

func (x *Status) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *Status) GetState() STATE {
	if x != nil {
		return x.State
	}
	return STATE_UNKNOWN
}

func (x *Status) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *Status) GetStopTime() int64 {
	if x != nil {
		return x.StopTime
	}
	return 0
}

func (x *Status) GetStdout() string {
	if x != nil {
		return x.Stdout
	}
	return ""
}

func (x *Status) GetStderr() string {
	if x != nil {
		return x.Stderr
	}
	return ""
}

func (x *Status) GetExitCode() int32 {
	if x != nil {
		return x.ExitCode
	}
	return 0
}

func (x *Status) GetTaskErr() []string {
	if x != nil {
		return x.TaskErr
	}
	return nil
}

type PushServer struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ID     string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Type   string   `protobuf:"bytes,2,opt,name=Type,proto3" json:"Type,omitempty"` //"RESTful"
	Server string   `protobuf:"bytes,3,opt,name=Server,proto3" json:"Server,omitempty"`
	Tags   []string `protobuf:"bytes,4,rep,name=Tags,proto3" json:"Tags,omitempty"`
}

func (x *PushServer) Reset() {
	*x = PushServer{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PushServer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PushServer) ProtoMessage() {}

func (x *PushServer) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PushServer.ProtoReflect.Descriptor instead.
func (*PushServer) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{7}
}

func (x *PushServer) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *PushServer) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *PushServer) GetServer() string {
	if x != nil {
		return x.Server
	}
	return ""
}

func (x *PushServer) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

type BOOL struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Result bool `protobuf:"varint,1,opt,name=Result,proto3" json:"Result,omitempty"`
}

func (x *BOOL) Reset() {
	*x = BOOL{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BOOL) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BOOL) ProtoMessage() {}

func (x *BOOL) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BOOL.ProtoReflect.Descriptor instead.
func (*BOOL) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{8}
}

func (x *BOOL) GetResult() bool {
	if x != nil {
		return x.Result
	}
	return false
}

type ID struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (x *ID) Reset() {
	*x = ID{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ID) ProtoMessage() {}

func (x *ID) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ID.ProtoReflect.Descriptor instead.
func (*ID) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{9}
}

func (x *ID) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

type CmdReturnLine struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ID   string            `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Type RETURNLINEMSGTYPE `protobuf:"varint,2,opt,name=Type,proto3,enum=api.RETURNLINEMSGTYPE" json:"Type,omitempty"`
	Line string            `protobuf:"bytes,3,opt,name=Line,proto3" json:"Line,omitempty"`
	Time int64             `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	SNum int64             `protobuf:"varint,5,opt,name=SNum,proto3" json:"SNum,omitempty"`
}

func (x *CmdReturnLine) Reset() {
	*x = CmdReturnLine{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CmdReturnLine) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CmdReturnLine) ProtoMessage() {}

func (x *CmdReturnLine) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CmdReturnLine.ProtoReflect.Descriptor instead.
func (*CmdReturnLine) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{10}
}

func (x *CmdReturnLine) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *CmdReturnLine) GetType() RETURNLINEMSGTYPE {
	if x != nil {
		return x.Type
	}
	return RETURNLINEMSGTYPE_STDOUT
}

func (x *CmdReturnLine) GetLine() string {
	if x != nil {
		return x.Line
	}
	return ""
}

func (x *CmdReturnLine) GetTime() int64 {
	if x != nil {
		return x.Time
	}
	return 0
}

func (x *CmdReturnLine) GetSNum() int64 {
	if x != nil {
		return x.SNum
	}
	return 0
}

type TaskRecurring struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TargetHosts    []string `protobuf:"bytes,1,rep,name=TargetHosts,proto3" json:"TargetHosts,omitempty"`
	CmdLine        string   `protobuf:"bytes,2,opt,name=CmdLine,proto3" json:"CmdLine,omitempty"`
	ExpectedResult string   `protobuf:"bytes,3,opt,name=ExpectedResult,proto3" json:"ExpectedResult,omitempty"`
	//false -- defalt report abnormal list; true -- report normal list
	ReportNormalList bool     `protobuf:"varint,4,opt,name=ReportNormalList,proto3" json:"ReportNormalList,omitempty"`
	Timeout          int64    `protobuf:"varint,5,opt,name=timeout,proto3" json:"timeout,omitempty"`
	IntervalSecond   int64    `protobuf:"varint,6,opt,name=intervalSecond,proto3" json:"intervalSecond,omitempty"`
	Tags             []string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (x *TaskRecurring) Reset() {
	*x = TaskRecurring{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TaskRecurring) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskRecurring) ProtoMessage() {}

func (x *TaskRecurring) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskRecurring.ProtoReflect.Descriptor instead.
func (*TaskRecurring) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{11}
}

func (x *TaskRecurring) GetTargetHosts() []string {
	if x != nil {
		return x.TargetHosts
	}
	return nil
}

func (x *TaskRecurring) GetCmdLine() string {
	if x != nil {
		return x.CmdLine
	}
	return ""
}

func (x *TaskRecurring) GetExpectedResult() string {
	if x != nil {
		return x.ExpectedResult
	}
	return ""
}

func (x *TaskRecurring) GetReportNormalList() bool {
	if x != nil {
		return x.ReportNormalList
	}
	return false
}

func (x *TaskRecurring) GetTimeout() int64 {
	if x != nil {
		return x.Timeout
	}
	return 0
}

func (x *TaskRecurring) GetIntervalSecond() int64 {
	if x != nil {
		return x.IntervalSecond
	}
	return 0
}

func (x *TaskRecurring) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

type TomlConf struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	//TomlContent must conform the definition of VerifyngCluster in
	//specialtasks/verifyingcluster/verifyingcluster.go
	//or EnsureICSEBDA Batch Deploying Agents of ICSE
	TomlContent string `protobuf:"bytes,1,opt,name=TomlContent,proto3" json:"TomlContent,omitempty"`
}

func (x *TomlConf) Reset() {
	*x = TomlConf{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TomlConf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TomlConf) ProtoMessage() {}

func (x *TomlConf) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TomlConf.ProtoReflect.Descriptor instead.
func (*TomlConf) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{12}
}

func (x *TomlConf) GetTomlContent() string {
	if x != nil {
		return x.TomlContent
	}
	return ""
}

type TaskVerifyCluster struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	PlanID     string   `protobuf:"bytes,1,opt,name=PlanID,proto3" json:"PlanID,omitempty"`
	TimeoutMin int64    `protobuf:"varint,2,opt,name=TimeoutMin,proto3" json:"TimeoutMin,omitempty"`
	Tags       []string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty"`
}

func (x *TaskVerifyCluster) Reset() {
	*x = TaskVerifyCluster{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TaskVerifyCluster) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskVerifyCluster) ProtoMessage() {}

func (x *TaskVerifyCluster) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskVerifyCluster.ProtoReflect.Descriptor instead.
func (*TaskVerifyCluster) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{13}
}

func (x *TaskVerifyCluster) GetPlanID() string {
	if x != nil {
		return x.PlanID
	}
	return ""
}

func (x *TaskVerifyCluster) GetTimeoutMin() int64 {
	if x != nil {
		return x.TimeoutMin
	}
	return 0
}

func (x *TaskVerifyCluster) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

type KV struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
}

func (x *KV) Reset() {
	*x = KV{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *KV) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KV) ProtoMessage() {}

func (x *KV) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KV.ProtoReflect.Descriptor instead.
func (*KV) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{14}
}

func (x *KV) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KV) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type HttpRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Method     HTTPMETHOD `protobuf:"varint,1,opt,name=Method,proto3,enum=api.HTTPMETHOD" json:"Method,omitempty"`
	Url        string     `protobuf:"bytes,2,opt,name=Url,proto3" json:"Url,omitempty"`
	Proto      string     `protobuf:"bytes,3,opt,name=Proto,proto3" json:"Proto,omitempty"` //default "HTTP/1.1"
	Header     []*KV      `protobuf:"bytes,4,rep,name=Header,proto3" json:"Header,omitempty"`
	Body       string     `protobuf:"bytes,5,opt,name=Body,proto3" json:"Body,omitempty"`
	TimeoutSec int64      `protobuf:"varint,6,opt,name=TimeoutSec,proto3" json:"TimeoutSec,omitempty"`
}

func (x *HttpRequest) Reset() {
	*x = HttpRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HttpRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpRequest) ProtoMessage() {}

func (x *HttpRequest) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpRequest.ProtoReflect.Descriptor instead.
func (*HttpRequest) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{15}
}

func (x *HttpRequest) GetMethod() HTTPMETHOD {
	if x != nil {
		return x.Method
	}
	return HTTPMETHOD_GET
}

func (x *HttpRequest) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *HttpRequest) GetProto() string {
	if x != nil {
		return x.Proto
	}
	return ""
}

func (x *HttpRequest) GetHeader() []*KV {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *HttpRequest) GetBody() string {
	if x != nil {
		return x.Body
	}
	return ""
}

func (x *HttpRequest) GetTimeoutSec() int64 {
	if x != nil {
		return x.TimeoutSec
	}
	return 0
}

type HttpResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Status string `protobuf:"bytes,1,opt,name=Status,proto3" json:"Status,omitempty"`
	Proto  string `protobuf:"bytes,2,opt,name=Proto,proto3" json:"Proto,omitempty"`
	Header []*KV  `protobuf:"bytes,3,rep,name=Header,proto3" json:"Header,omitempty"`
	Body   string `protobuf:"bytes,4,opt,name=Body,proto3" json:"Body,omitempty"`
}

func (x *HttpResponse) Reset() {
	*x = HttpResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *HttpResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpResponse) ProtoMessage() {}

func (x *HttpResponse) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpResponse.ProtoReflect.Descriptor instead.
func (*HttpResponse) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{16}
}

func (x *HttpResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *HttpResponse) GetProto() string {
	if x != nil {
		return x.Proto
	}
	return ""
}

func (x *HttpResponse) GetHeader() []*KV {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *HttpResponse) GetBody() string {
	if x != nil {
		return x.Body
	}
	return ""
}

//symbol *** in comment means not showing in definition or init periods
type WorkFlowSchema struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ID          string                  `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	BeginNode   *WorkFlowSchema_BNode   `protobuf:"bytes,2,opt,name=BeginNode,proto3" json:"BeginNode,omitempty"`
	WorkerNodes []*WorkFlowSchema_WNode `protobuf:"bytes,3,rep,name=WorkerNodes,proto3" json:"WorkerNodes,omitempty"`
	EndNode     *WorkFlowSchema_ENode   `protobuf:"bytes,4,opt,name=EndNode,proto3" json:"EndNode,omitempty"`
}

func (x *WorkFlowSchema) Reset() {
	*x = WorkFlowSchema{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WorkFlowSchema) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkFlowSchema) ProtoMessage() {}

func (x *WorkFlowSchema) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkFlowSchema.ProtoReflect.Descriptor instead.
func (*WorkFlowSchema) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{17}
}

func (x *WorkFlowSchema) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *WorkFlowSchema) GetBeginNode() *WorkFlowSchema_BNode {
	if x != nil {
		return x.BeginNode
	}
	return nil
}

func (x *WorkFlowSchema) GetWorkerNodes() []*WorkFlowSchema_WNode {
	if x != nil {
		return x.WorkerNodes
	}
	return nil
}

func (x *WorkFlowSchema) GetEndNode() *WorkFlowSchema_ENode {
	if x != nil {
		return x.EndNode
	}
	return nil
}

// first using Schema, if nil, using TomlConf to fill Schema
type TaskWorkFlow struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Schema     *WorkFlowSchema `protobuf:"bytes,1,opt,name=Schema,proto3" json:"Schema,omitempty"`
	TomlConf   []byte          `protobuf:"bytes,2,opt,name=TomlConf,proto3" json:"TomlConf,omitempty"`
	TimeoutMin int64           `protobuf:"varint,3,opt,name=TimeoutMin,proto3" json:"TimeoutMin,omitempty"`
	//tags -- used to set push servers
	Tags []string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	//NoWaitingNodes -- those not be activated to wait to run (with STOPPED State)
	NoWaitingNodes []string `protobuf:"bytes,5,rep,name=NoWaitingNodes,proto3" json:"NoWaitingNodes,omitempty"`
	//OverrideHalfWayKVs -- is prior to workernode.HalfWayKVs. and override it.
	//default OverrideHalfWayKVs is empty, workernode.HalfWayKVs will work.
	OverrideHalfWayKVs map[string]string `protobuf:"bytes,6,rep,name=OverrideHalfWayKVs,proto3" json:"OverrideHalfWayKVs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *TaskWorkFlow) Reset() {
	*x = TaskWorkFlow{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TaskWorkFlow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaskWorkFlow) ProtoMessage() {}

func (x *TaskWorkFlow) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaskWorkFlow.ProtoReflect.Descriptor instead.
func (*TaskWorkFlow) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{18}
}

func (x *TaskWorkFlow) GetSchema() *WorkFlowSchema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *TaskWorkFlow) GetTomlConf() []byte {
	if x != nil {
		return x.TomlConf
	}
	return nil
}

func (x *TaskWorkFlow) GetTimeoutMin() int64 {
	if x != nil {
		return x.TimeoutMin
	}
	return 0
}

func (x *TaskWorkFlow) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *TaskWorkFlow) GetNoWaitingNodes() []string {
	if x != nil {
		return x.NoWaitingNodes
	}
	return nil
}

func (x *TaskWorkFlow) GetOverrideHalfWayKVs() map[string]string {
	if x != nil {
		return x.OverrideHalfWayKVs
	}
	return nil
}

type BlackBoardKVs struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TWFID *ID               `protobuf:"bytes,1,opt,name=TWFID,proto3" json:"TWFID,omitempty"`
	KVs   map[string]string `protobuf:"bytes,2,rep,name=KVs,proto3" json:"KVs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *BlackBoardKVs) Reset() {
	*x = BlackBoardKVs{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BlackBoardKVs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlackBoardKVs) ProtoMessage() {}

func (x *BlackBoardKVs) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlackBoardKVs.ProtoReflect.Descriptor instead.
func (*BlackBoardKVs) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{19}
}

func (x *BlackBoardKVs) GetTWFID() *ID {
	if x != nil {
		return x.TWFID
	}
	return nil
}

func (x *BlackBoardKVs) GetKVs() map[string]string {
	if x != nil {
		return x.KVs
	}
	return nil
}

//three kinds of Node:
//BNode -- to begin the workflow with inputs (Outputs to WNodes)
type WorkFlowSchema_BNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	OutKVs map[string]string `protobuf:"bytes,1,rep,name=OutKVs,proto3" json:"OutKVs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *WorkFlowSchema_BNode) Reset() {
	*x = WorkFlowSchema_BNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WorkFlowSchema_BNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkFlowSchema_BNode) ProtoMessage() {}

func (x *WorkFlowSchema_BNode) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkFlowSchema_BNode.ProtoReflect.Descriptor instead.
func (*WorkFlowSchema_BNode) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{17, 0}
}

func (x *WorkFlowSchema_BNode) GetOutKVs() map[string]string {
	if x != nil {
		return x.OutKVs
	}
	return nil
}

//WNode -- the workers to do jobs in hosts
type WorkFlowSchema_WNode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	ID                string           `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	TriggerExpression string           `protobuf:"bytes,2,opt,name=TriggerExpression,proto3" json:"TriggerExpression,omitempty"`
	NodeTask          *TaskCommandLine `protobuf:"bytes,3,opt,name=NodeTask,proto3" json:"NodeTask,omitempty"`
	//PlaceHolderFromBB -- Placeholder in script
	//which will be replace with its value by key from BlackBoard
	//when the node is triggered.
	PlaceHolderFromBB []string          `protobuf:"bytes,4,rep,name=PlaceHolderFromBB,proto3" json:"PlaceHolderFromBB,omitempty"`
	Status            *Status           `protobuf:"bytes,5,opt,name=Status,proto3" json:"Status,omitempty"` //***
	OutKVs            map[string]string `protobuf:"bytes,6,rep,name=OutKVs,proto3" json:"OutKVs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	//write to BlackBoard when failed in cases of network issues or timeout, etc.
	//notice: this doesn't include application failures which should be handle in
	//scripts of NodeTask
	FailedKVs map[string]string `protobuf:"bytes,7,rep,name=FailedKVs,proto3" json:"FailedKVs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	//ReEntryWaitingSeconds -- for reenter this node. engine will wait
	//ReEntryWaitingSeconds seconds after finishing or
	//failing this node and set node state to waiting and move Status to
	//ReEnterHistory.
	//if ReEntryWaitingSeconds <= 0, no reenter this node. default is 0
	ReEnterWaitingSeconds int64     `protobuf:"varint,8,opt,name=ReEnterWaitingSeconds,proto3" json:"ReEnterWaitingSeconds,omitempty"`
	ReEnterHistory        []*Status `protobuf:"bytes,9,rep,name=ReEnterHistory,proto3" json:"ReEnterHistory,omitempty"` //***
	NodeTaskID            string    `protobuf:"bytes,10,opt,name=NodeTaskID,proto3" json:"NodeTaskID,omitempty"`        //***
}

func (x *WorkFlowSchema_WNode) Reset() {
	*x = WorkFlowSchema_WNode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WorkFlowSchema_WNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkFlowSchema_WNode) ProtoMessage() {}

func (x *WorkFlowSchema_WNode) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkFlowSchema_WNode.ProtoReflect.Descriptor instead.
func (*WorkFlowSchema_WNode) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{17, 1}
}

func (x *WorkFlowSchema_WNode) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *WorkFlowSchema_WNode) GetTriggerExpression() string {
	if x != nil {
		return x.TriggerExpression
	}
	return ""
}

func (x *WorkFlowSchema_WNode) GetNodeTask() *TaskCommandLine {
	if x != nil {
		return x.NodeTask
	}
	return nil
}

func (x *WorkFlowSchema_WNode) GetPlaceHolderFromBB() []string {
	if x != nil {
		return x.PlaceHolderFromBB
	}
	return nil
}

func (x *WorkFlowSchema_WNode) GetStatus() *Status {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *WorkFlowSchema_WNode) GetOutKVs() map[string]string {
	if x != nil {
		return x.OutKVs
	}
	return nil
}

func (x *WorkFlowSchema_WNode) GetFailedKVs() map[string]string {
	if x != nil {
		return x.FailedKVs
	}
	return nil
}

func (x *WorkFlowSchema_WNode) GetReEnterWaitingSeconds() int64 {
	if x != nil {
		return x.ReEnterWaitingSeconds
	}
	return 0
}

func (x *WorkFlowSchema_WNode) GetReEnterHistory() []*Status {
	if x != nil {
		return x.ReEnterHistory
	}
	return nil
}

func (x *WorkFlowSchema_WNode) GetNodeTaskID() string {
	if x != nil {
		return x.NodeTaskID
	}
	return ""
}

//ENode -- to end the workflow with final result
type WorkFlowSchema_ENode struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	TriggerExpression string `protobuf:"bytes,1,opt,name=TriggerExpression,proto3" json:"TriggerExpression,omitempty"`
	ResultExpression  string `protobuf:"bytes,2,opt,name=ResultExpression,proto3" json:"ResultExpression,omitempty"`
	Result            string `protobuf:"bytes,3,opt,name=Result,proto3" json:"Result,omitempty"`               //***
	State             STATE  `protobuf:"varint,4,opt,name=State,proto3,enum=api.STATE" json:"State,omitempty"` //***
}

func (x *WorkFlowSchema_ENode) Reset() {
	*x = WorkFlowSchema_ENode{}
	if protoimpl.UnsafeEnabled {
		mi := &file_api_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *WorkFlowSchema_ENode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkFlowSchema_ENode) ProtoMessage() {}

func (x *WorkFlowSchema_ENode) ProtoReflect() protoreflect.Message {
	mi := &file_api_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkFlowSchema_ENode.ProtoReflect.Descriptor instead.
func (*WorkFlowSchema_ENode) Descriptor() ([]byte, []int) {
	return file_api_proto_rawDescGZIP(), []int{17, 2}
}

func (x *WorkFlowSchema_ENode) GetTriggerExpression() string {
	if x != nil {
		return x.TriggerExpression
	}
	return ""
}

func (x *WorkFlowSchema_ENode) GetResultExpression() string {
	if x != nil {
		return x.ResultExpression
	}
	return ""
}

func (x *WorkFlowSchema_ENode) GetResult() string {
	if x != nil {
		return x.Result
	}
	return ""
}

func (x *WorkFlowSchema_ENode) GetState() STATE {
	if x != nil {
		return x.State
	}
	return STATE_UNKNOWN
}

var File_api_proto protoreflect.FileDescriptor

var file_api_proto_rawDesc = []byte{
	0x0a, 0x09, 0x61, 0x70, 0x69, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x03, 0x61, 0x70, 0x69,
	0x22, 0x8d, 0x01, 0x0a, 0x0f, 0x54, 0x61, 0x73, 0x6b, 0x44, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x41,
	0x67, 0x65, 0x6e, 0x74, 0x12, 0x22, 0x0a, 0x0c, 0x49, 0x50, 0x6f, 0x72, 0x48, 0x6f, 0x73, 0x74,
	0x4e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x49, 0x50, 0x6f, 0x72,
	0x48, 0x6f, 0x73, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x1a, 0x0a, 0x08,
	0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
	0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x54, 0x61, 0x67, 0x73,
	0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x54, 0x61, 0x67, 0x73, 0x12, 0x12, 0x0a, 0x04,
	0x50, 0x6f, 0x72, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x50, 0x6f, 0x72, 0x74,
	0x22, 0x8d, 0x01, 0x0a, 0x0f, 0x54, 0x61, 0x73, 0x6b, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64,
	0x4c, 0x69, 0x6e, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x45, 0x78, 0x65, 0x63, 0x48, 0x6f, 0x73, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x45, 0x78, 0x65, 0x63, 0x48, 0x6f, 0x73, 0x74,
	0x12, 0x18, 0x0a, 0x07, 0x43, 0x6d, 0x64, 0x4c, 0x69, 0x6e, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x07, 0x43, 0x6d, 0x64, 0x4c, 0x69, 0x6e, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x74, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x74, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x54, 0x61, 0x67, 0x73, 0x18, 0x04, 0x20, 0x03,
	0x28, 0x09, 0x52, 0x04, 0x54, 0x61, 0x67, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x4f, 0x53, 0x55, 0x73,
	0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x4f, 0x53, 0x55, 0x73, 0x65, 0x72,
	0x22, 0x47, 0x0a, 0x09, 0x43, 0x6d, 0x64, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x0e, 0x0a,
	0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12, 0x18, 0x0a,
	0x07, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
	0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x64, 0x35, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6d, 0x64, 0x35, 0x22, 0x96, 0x01, 0x0a, 0x10, 0x54, 0x61,
	0x73, 0x6b, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x4f, 0x6e, 0x48, 0x6f, 0x73, 0x74, 0x12, 0x1a,
	0x0a, 0x08, 0x45, 0x78, 0x65, 0x63, 0x48, 0x6f, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x08, 0x45, 0x78, 0x65, 0x63, 0x48, 0x6f, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12, 0x18, 0x0a, 0x07, 0x74, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x74, 0x69, 0x6d,
	0x65, 0x6f, 0x75, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6d, 0x64, 0x35, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x6d, 0x64, 0x35, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x05,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x4f, 0x53,
	0x55, 0x73, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x4f, 0x53, 0x55, 0x73,
	0x65, 0x72, 0x22, 0xc9, 0x01, 0x0a, 0x0b, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x63, 0x70, 0x46, 0x69,
	0x6c, 0x65, 0x12, 0x38, 0x0a, 0x0d, 0x43, 0x6f, 0x70, 0x79, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x43, 0x4f, 0x50, 0x59, 0x44, 0x49, 0x52, 0x45, 0x43, 0x54, 0x49, 0x4f, 0x4e, 0x52, 0x0d, 0x43,
	0x6f, 0x70, 0x79, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1e, 0x0a, 0x0a,
	0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x48, 0x6f, 0x73, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0a, 0x52, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x48, 0x6f, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07,
	0x53, 0x72, 0x63, 0x46, 0x69, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x53,
	0x72, 0x63, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x44, 0x73, 0x74, 0x46, 0x69, 0x6c,
	0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x44, 0x73, 0x74, 0x46, 0x69, 0x6c, 0x65,
	0x12, 0x18, 0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x61,
	0x67, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x22, 0x07,
	0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0xda, 0x01, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
	0x49, 0x44, 0x12, 0x20, 0x0a, 0x05, 0x53, 0x74, 0x61, 0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x0e, 0x32, 0x0a, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x54, 0x41, 0x54, 0x45, 0x52, 0x05, 0x53,
	0x74, 0x61, 0x74, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d,
	0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x53, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69,
	0x6d, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x53, 0x74, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x53, 0x74, 0x6f, 0x70, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x16,
	0x0a, 0x06, 0x53, 0x74, 0x64, 0x6f, 0x75, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x53, 0x74, 0x64, 0x6f, 0x75, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x53, 0x74, 0x64, 0x65, 0x72, 0x72,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x53, 0x74, 0x64, 0x65, 0x72, 0x72, 0x12, 0x1a,
	0x0a, 0x08, 0x45, 0x78, 0x69, 0x74, 0x43, 0x6f, 0x64, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x08, 0x45, 0x78, 0x69, 0x74, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x54, 0x61,
	0x73, 0x6b, 0x45, 0x72, 0x72, 0x18, 0x08, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x54, 0x61, 0x73,
	0x6b, 0x45, 0x72, 0x72, 0x22, 0x5c, 0x0a, 0x0a, 0x50, 0x75, 0x73, 0x68, 0x53, 0x65, 0x72, 0x76,
	0x65, 0x72, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02,
	0x49, 0x44, 0x12, 0x12, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x12,
	0x0a, 0x04, 0x54, 0x61, 0x67, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x54, 0x61,
	0x67, 0x73, 0x22, 0x1e, 0x0a, 0x04, 0x42, 0x4f, 0x4f, 0x4c, 0x12, 0x16, 0x0a, 0x06, 0x52, 0x65,
	0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x52, 0x65, 0x73, 0x75,
	0x6c, 0x74, 0x22, 0x14, 0x0a, 0x02, 0x49, 0x44, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x22, 0x87, 0x01, 0x0a, 0x0d, 0x43, 0x6d, 0x64,
	0x52, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x4c, 0x69, 0x6e, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12, 0x2a, 0x0a, 0x04, 0x54, 0x79,
	0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x16, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x52,
	0x45, 0x54, 0x55, 0x52, 0x4e, 0x4c, 0x49, 0x4e, 0x45, 0x4d, 0x53, 0x47, 0x54, 0x59, 0x50, 0x45,
	0x52, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x4c, 0x69, 0x6e, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x4c, 0x69, 0x6e, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x69,
	0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x74, 0x69, 0x6d, 0x65, 0x12, 0x12,
	0x0a, 0x04, 0x53, 0x4e, 0x75, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x04, 0x53, 0x4e,
	0x75, 0x6d, 0x22, 0xf5, 0x01, 0x0a, 0x0d, 0x54, 0x61, 0x73, 0x6b, 0x52, 0x65, 0x63, 0x75, 0x72,
	0x72, 0x69, 0x6e, 0x67, 0x12, 0x20, 0x0a, 0x0b, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x48, 0x6f,
	0x73, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x54, 0x61, 0x72, 0x67, 0x65,
	0x74, 0x48, 0x6f, 0x73, 0x74, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x43, 0x6d, 0x64, 0x4c, 0x69, 0x6e,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x43, 0x6d, 0x64, 0x4c, 0x69, 0x6e, 0x65,
	0x12, 0x26, 0x0a, 0x0e, 0x45, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x52, 0x65, 0x73, 0x75,
	0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x45, 0x78, 0x70, 0x65, 0x63, 0x74,
	0x65, 0x64, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x2a, 0x0a, 0x10, 0x52, 0x65, 0x70, 0x6f,
	0x72, 0x74, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x4c, 0x69, 0x73, 0x74, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x10, 0x52, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x4e, 0x6f, 0x72, 0x6d, 0x61, 0x6c,
	0x4c, 0x69, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18,
	0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x26,
	0x0a, 0x0e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0e, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x07,
	0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x22, 0x2c, 0x0a, 0x08, 0x54, 0x6f,
	0x6d, 0x6c, 0x43, 0x6f, 0x6e, 0x66, 0x12, 0x20, 0x0a, 0x0b, 0x54, 0x6f, 0x6d, 0x6c, 0x43, 0x6f,
	0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x54, 0x6f, 0x6d,
	0x6c, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x22, 0x5f, 0x0a, 0x11, 0x54, 0x61, 0x73, 0x6b,
	0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x12, 0x16, 0x0a,
	0x06, 0x50, 0x6c, 0x61, 0x6e, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x50,
	0x6c, 0x61, 0x6e, 0x49, 0x44, 0x12, 0x1e, 0x0a, 0x0a, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74,
	0x4d, 0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0a, 0x54, 0x69, 0x6d, 0x65, 0x6f,
	0x75, 0x74, 0x4d, 0x69, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x03, 0x20,
	0x03, 0x28, 0x09, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x22, 0x2c, 0x0a, 0x02, 0x4b, 0x56, 0x12,
	0x10, 0x0a, 0x03, 0x4b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x4b, 0x65,
	0x79, 0x12, 0x14, 0x0a, 0x05, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x05, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x22, 0xb3, 0x01, 0x0a, 0x0b, 0x48, 0x74, 0x74, 0x70,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x27, 0x0a, 0x06, 0x4d, 0x65, 0x74, 0x68, 0x6f,
	0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0f, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x48, 0x54,
	0x54, 0x50, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44, 0x52, 0x06, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64,
	0x12, 0x10, 0x0a, 0x03, 0x55, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x55,
	0x72, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1f, 0x0a, 0x06, 0x48, 0x65, 0x61, 0x64,
	0x65, 0x72, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x4b,
	0x56, 0x52, 0x06, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x42, 0x6f, 0x64,
	0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x42, 0x6f, 0x64, 0x79, 0x12, 0x1e, 0x0a,
	0x0a, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x03, 0x52, 0x0a, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x53, 0x65, 0x63, 0x22, 0x71, 0x0a,
	0x0c, 0x48, 0x74, 0x74, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a,
	0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x53,
	0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1f, 0x0a, 0x06, 0x48,
	0x65, 0x61, 0x64, 0x65, 0x72, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x07, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x4b, 0x56, 0x52, 0x06, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04,
	0x42, 0x6f, 0x64, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x42, 0x6f, 0x64, 0x79,
	0x22, 0xc5, 0x08, 0x0a, 0x0e, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x63, 0x68,
	0x65, 0x6d, 0x61, 0x12, 0x0e, 0x0a, 0x02, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x02, 0x49, 0x44, 0x12, 0x37, 0x0a, 0x09, 0x42, 0x65, 0x67, 0x69, 0x6e, 0x4e, 0x6f, 0x64, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57, 0x6f, 0x72,
	0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x42, 0x4e, 0x6f, 0x64,
	0x65, 0x52, 0x09, 0x42, 0x65, 0x67, 0x69, 0x6e, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x3b, 0x0a, 0x0b,
	0x57, 0x6f, 0x72, 0x6b, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x19, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77,
	0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x57, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x0b, 0x57, 0x6f,
	0x72, 0x6b, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x12, 0x33, 0x0a, 0x07, 0x45, 0x6e, 0x64,
	0x4e, 0x6f, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e,
	0x45, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x07, 0x45, 0x6e, 0x64, 0x4e, 0x6f, 0x64, 0x65, 0x1a, 0x81,
	0x01, 0x0a, 0x05, 0x42, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x3d, 0x0a, 0x06, 0x4f, 0x75, 0x74, 0x4b,
	0x56, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57,
	0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x42, 0x4e,
	0x6f, 0x64, 0x65, 0x2e, 0x4f, 0x75, 0x74, 0x4b, 0x56, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52,
	0x06, 0x4f, 0x75, 0x74, 0x4b, 0x56, 0x73, 0x1a, 0x39, 0x0a, 0x0b, 0x4f, 0x75, 0x74, 0x4b, 0x56,
	0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
	0x38, 0x01, 0x1a, 0xd5, 0x04, 0x0a, 0x05, 0x57, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x0e, 0x0a, 0x02,
	0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x49, 0x44, 0x12, 0x2c, 0x0a, 0x11,
	0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f,
	0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72,
	0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x30, 0x0a, 0x08, 0x4e, 0x6f,
	0x64, 0x65, 0x54, 0x61, 0x73, 0x6b, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x61,
	0x70, 0x69, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x4c, 0x69,
	0x6e, 0x65, 0x52, 0x08, 0x4e, 0x6f, 0x64, 0x65, 0x54, 0x61, 0x73, 0x6b, 0x12, 0x2c, 0x0a, 0x11,
	0x50, 0x6c, 0x61, 0x63, 0x65, 0x48, 0x6f, 0x6c, 0x64, 0x65, 0x72, 0x46, 0x72, 0x6f, 0x6d, 0x42,
	0x42, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x11, 0x50, 0x6c, 0x61, 0x63, 0x65, 0x48, 0x6f,
	0x6c, 0x64, 0x65, 0x72, 0x46, 0x72, 0x6f, 0x6d, 0x42, 0x42, 0x12, 0x23, 0x0a, 0x06, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12,
	0x3d, 0x0a, 0x06, 0x4f, 0x75, 0x74, 0x4b, 0x56, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x25, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x63,
	0x68, 0x65, 0x6d, 0x61, 0x2e, 0x57, 0x4e, 0x6f, 0x64, 0x65, 0x2e, 0x4f, 0x75, 0x74, 0x4b, 0x56,
	0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x4f, 0x75, 0x74, 0x4b, 0x56, 0x73, 0x12, 0x46,
	0x0a, 0x09, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x4b, 0x56, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x28, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77,
	0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x2e, 0x57, 0x4e, 0x6f, 0x64, 0x65, 0x2e, 0x46, 0x61, 0x69,
	0x6c, 0x65, 0x64, 0x4b, 0x56, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x09, 0x46, 0x61, 0x69,
	0x6c, 0x65, 0x64, 0x4b, 0x56, 0x73, 0x12, 0x34, 0x0a, 0x15, 0x52, 0x65, 0x45, 0x6e, 0x74, 0x65,
	0x72, 0x57, 0x61, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18,
	0x08, 0x20, 0x01, 0x28, 0x03, 0x52, 0x15, 0x52, 0x65, 0x45, 0x6e, 0x74, 0x65, 0x72, 0x57, 0x61,
	0x69, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x12, 0x33, 0x0a, 0x0e,
	0x52, 0x65, 0x45, 0x6e, 0x74, 0x65, 0x72, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x18, 0x09,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x0b, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x52, 0x0e, 0x52, 0x65, 0x45, 0x6e, 0x74, 0x65, 0x72, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72,
	0x79, 0x12, 0x1e, 0x0a, 0x0a, 0x4e, 0x6f, 0x64, 0x65, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x44, 0x18,
	0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x4e, 0x6f, 0x64, 0x65, 0x54, 0x61, 0x73, 0x6b, 0x49,
	0x44, 0x1a, 0x39, 0x0a, 0x0b, 0x4f, 0x75, 0x74, 0x4b, 0x56, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
	0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b,
	0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x3c, 0x0a, 0x0e,
	0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x4b, 0x56, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x9b, 0x01, 0x0a, 0x05, 0x45,
	0x4e, 0x6f, 0x64, 0x65, 0x12, 0x2c, 0x0a, 0x11, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x45,
	0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x11, 0x54, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x12, 0x2a, 0x0a, 0x10, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x45, 0x78, 0x70, 0x72,
	0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x52, 0x65,
	0x73, 0x75, 0x6c, 0x74, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x16,
	0x0a, 0x06, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x20, 0x0a, 0x05, 0x53, 0x74, 0x61, 0x74, 0x65, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x0a, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x54, 0x41, 0x54,
	0x45, 0x52, 0x05, 0x53, 0x74, 0x61, 0x74, 0x65, 0x22, 0xd5, 0x02, 0x0a, 0x0c, 0x54, 0x61, 0x73,
	0x6b, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x2b, 0x0a, 0x06, 0x53, 0x63, 0x68,
	0x65, 0x6d, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x52, 0x06,
	0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x1a, 0x0a, 0x08, 0x54, 0x6f, 0x6d, 0x6c, 0x43, 0x6f,
	0x6e, 0x66, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x54, 0x6f, 0x6d, 0x6c, 0x43, 0x6f,
	0x6e, 0x66, 0x12, 0x1e, 0x0a, 0x0a, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x4d, 0x69, 0x6e,
	0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0a, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x4d,
	0x69, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09,
	0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x26, 0x0a, 0x0e, 0x4e, 0x6f, 0x57, 0x61, 0x69, 0x74,
	0x69, 0x6e, 0x67, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0e,
	0x4e, 0x6f, 0x57, 0x61, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x12, 0x59,
	0x0a, 0x12, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x48, 0x61, 0x6c, 0x66, 0x57, 0x61,
	0x79, 0x4b, 0x56, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x54, 0x61, 0x73, 0x6b, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x2e, 0x4f, 0x76,
	0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x48, 0x61, 0x6c, 0x66, 0x57, 0x61, 0x79, 0x4b, 0x56, 0x73,
	0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x12, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x48,
	0x61, 0x6c, 0x66, 0x57, 0x61, 0x79, 0x4b, 0x56, 0x73, 0x1a, 0x45, 0x0a, 0x17, 0x4f, 0x76, 0x65,
	0x72, 0x72, 0x69, 0x64, 0x65, 0x48, 0x61, 0x6c, 0x66, 0x57, 0x61, 0x79, 0x4b, 0x56, 0x73, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
	0x22, 0x95, 0x01, 0x0a, 0x0d, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x42, 0x6f, 0x61, 0x72, 0x64, 0x4b,
	0x56, 0x73, 0x12, 0x1d, 0x0a, 0x05, 0x54, 0x57, 0x46, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44, 0x52, 0x05, 0x54, 0x57, 0x46, 0x49,
	0x44, 0x12, 0x2d, 0x0a, 0x03, 0x4b, 0x56, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x42, 0x6f, 0x61, 0x72, 0x64, 0x4b,
	0x56, 0x73, 0x2e, 0x4b, 0x56, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x03, 0x4b, 0x56, 0x73,
	0x1a, 0x36, 0x0a, 0x08, 0x4b, 0x56, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
	0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14,
	0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
	0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x2a, 0xa7, 0x01, 0x0a, 0x08, 0x54, 0x41, 0x53,
	0x4b, 0x54, 0x59, 0x50, 0x45, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x41, 0x53, 0x4b, 0x43, 0x4d, 0x44,
	0x4c, 0x49, 0x4e, 0x45, 0x10, 0x00, 0x12, 0x11, 0x0a, 0x0d, 0x54, 0x41, 0x53, 0x4b, 0x43, 0x4d,
	0x44, 0x53, 0x43, 0x52, 0x49, 0x50, 0x54, 0x10, 0x01, 0x12, 0x13, 0x0a, 0x0f, 0x54, 0x41, 0x53,
	0x4b, 0x44, 0x45, 0x50, 0x4c, 0x4f, 0x59, 0x41, 0x47, 0x45, 0x4e, 0x54, 0x10, 0x02, 0x12, 0x0f,
	0x0a, 0x0b, 0x54, 0x41, 0x53, 0x4b, 0x53, 0x43, 0x50, 0x46, 0x49, 0x4c, 0x45, 0x10, 0x03, 0x12,
	0x11, 0x0a, 0x0d, 0x54, 0x41, 0x53, 0x4b, 0x52, 0x45, 0x43, 0x55, 0x52, 0x52, 0x49, 0x4e, 0x47,
	0x10, 0x04, 0x12, 0x15, 0x0a, 0x11, 0x54, 0x41, 0x53, 0x4b, 0x56, 0x45, 0x52, 0x49, 0x46, 0x59,
	0x43, 0x4c, 0x55, 0x53, 0x54, 0x45, 0x52, 0x10, 0x05, 0x12, 0x15, 0x0a, 0x11, 0x54, 0x41, 0x53,
	0x4b, 0x42, 0x44, 0x45, 0x50, 0x4c, 0x4f, 0x59, 0x41, 0x47, 0x45, 0x4e, 0x54, 0x53, 0x10, 0x06,
	0x12, 0x10, 0x0a, 0x0c, 0x54, 0x41, 0x53, 0x4b, 0x57, 0x4f, 0x52, 0x4b, 0x46, 0x4c, 0x4f, 0x57,
	0x10, 0x07, 0x2a, 0x29, 0x0a, 0x0d, 0x43, 0x4f, 0x50, 0x59, 0x44, 0x49, 0x52, 0x45, 0x43, 0x54,
	0x49, 0x4f, 0x4e, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x4f, 0x50, 0x59, 0x54, 0x4f, 0x10, 0x00, 0x12,
	0x0c, 0x0a, 0x08, 0x43, 0x4f, 0x50, 0x59, 0x46, 0x52, 0x4f, 0x4d, 0x10, 0x01, 0x2a, 0x92, 0x01,
	0x0a, 0x05, 0x53, 0x54, 0x41, 0x54, 0x45, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f,
	0x57, 0x4e, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x50, 0x45, 0x4e, 0x44, 0x49, 0x4e, 0x47, 0x10,
	0x01, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x55, 0x4e, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x0c,
	0x0a, 0x08, 0x43, 0x4f, 0x4d, 0x50, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07,
	0x53, 0x54, 0x4f, 0x50, 0x50, 0x45, 0x44, 0x10, 0x04, 0x12, 0x0b, 0x0a, 0x07, 0x54, 0x49, 0x4d,
	0x45, 0x4f, 0x55, 0x54, 0x10, 0x06, 0x12, 0x0e, 0x0a, 0x0a, 0x53, 0x53, 0x48, 0x4e, 0x45, 0x54,
	0x46, 0x41, 0x49, 0x4c, 0x10, 0x07, 0x12, 0x0c, 0x0a, 0x08, 0x54, 0x41, 0x53, 0x4b, 0x46, 0x41,
	0x49, 0x4c, 0x10, 0x08, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x41, 0x53, 0x4b, 0x4e, 0x4f, 0x45, 0x58,
	0x49, 0x53, 0x54, 0x10, 0x09, 0x12, 0x0b, 0x0a, 0x07, 0x57, 0x41, 0x49, 0x54, 0x49, 0x4e, 0x47,
	0x10, 0x0a, 0x2a, 0x8d, 0x01, 0x0a, 0x11, 0x52, 0x45, 0x54, 0x55, 0x52, 0x4e, 0x4c, 0x49, 0x4e,
	0x45, 0x4d, 0x53, 0x47, 0x54, 0x59, 0x50, 0x45, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x54, 0x44, 0x4f,
	0x55, 0x54, 0x10, 0x00, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x54, 0x44, 0x45, 0x52, 0x52, 0x10, 0x01,
	0x12, 0x0d, 0x0a, 0x09, 0x54, 0x41, 0x53, 0x4b, 0x53, 0x54, 0x41, 0x54, 0x45, 0x10, 0x02, 0x12,
	0x0c, 0x0a, 0x08, 0x45, 0x58, 0x49, 0x54, 0x43, 0x4f, 0x44, 0x45, 0x10, 0x03, 0x12, 0x0b, 0x0a,
	0x07, 0x54, 0x41, 0x53, 0x4b, 0x45, 0x52, 0x52, 0x10, 0x04, 0x12, 0x07, 0x0a, 0x03, 0x45, 0x4f,
	0x46, 0x10, 0x05, 0x12, 0x0e, 0x0a, 0x0a, 0x56, 0x45, 0x52, 0x49, 0x46, 0x59, 0x49, 0x54, 0x45,
	0x4d, 0x10, 0x06, 0x12, 0x0f, 0x0a, 0x0b, 0x42, 0x41, 0x54, 0x43, 0x48, 0x44, 0x45, 0x50, 0x4c,
	0x4f, 0x59, 0x10, 0x07, 0x12, 0x0c, 0x0a, 0x08, 0x57, 0x4f, 0x52, 0x4b, 0x46, 0x4c, 0x4f, 0x57,
	0x10, 0x08, 0x2a, 0x63, 0x0a, 0x0a, 0x48, 0x54, 0x54, 0x50, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44,
	0x12, 0x07, 0x0a, 0x03, 0x47, 0x45, 0x54, 0x10, 0x00, 0x12, 0x08, 0x0a, 0x04, 0x50, 0x4f, 0x53,
	0x54, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x50, 0x55, 0x54, 0x10, 0x02, 0x12, 0x0a, 0x0a, 0x06,
	0x44, 0x45, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x4f, 0x50, 0x54, 0x49,
	0x4f, 0x4e, 0x53, 0x10, 0x04, 0x12, 0x08, 0x0a, 0x04, 0x48, 0x45, 0x41, 0x44, 0x10, 0x05, 0x12,
	0x09, 0x0a, 0x05, 0x54, 0x52, 0x41, 0x43, 0x45, 0x10, 0x06, 0x12, 0x0b, 0x0a, 0x07, 0x43, 0x4f,
	0x4e, 0x4e, 0x45, 0x43, 0x54, 0x10, 0x07, 0x32, 0xe1, 0x08, 0x0a, 0x06, 0x43, 0x4d, 0x44, 0x53,
	0x76, 0x63, 0x12, 0x2d, 0x0a, 0x0d, 0x41, 0x64, 0x64, 0x50, 0x75, 0x73, 0x68, 0x53, 0x65, 0x72,
	0x76, 0x65, 0x72, 0x12, 0x0f, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x50, 0x75, 0x73, 0x68, 0x53, 0x65,
	0x72, 0x76, 0x65, 0x72, 0x1a, 0x09, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x42, 0x4f, 0x4f, 0x4c, 0x22,
	0x00, 0x12, 0x28, 0x0a, 0x10, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x50, 0x75, 0x73, 0x68, 0x53,
	0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44, 0x1a, 0x09,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x42, 0x4f, 0x4f, 0x4c, 0x22, 0x00, 0x12, 0x31, 0x0a, 0x0e, 0x4c,
	0x69, 0x73, 0x74, 0x50, 0x75, 0x73, 0x68, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x0a, 0x2e,
	0x61, 0x70, 0x69, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x0f, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x50, 0x75, 0x73, 0x68, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x22, 0x00, 0x30, 0x01, 0x12, 0x28,
	0x0a, 0x09, 0x41, 0x64, 0x64, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x0e, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x43, 0x6d, 0x64, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x1a, 0x09, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x42, 0x4f, 0x4f, 0x4c, 0x22, 0x00, 0x12, 0x24, 0x0a, 0x0c, 0x52, 0x65, 0x6d, 0x6f,
	0x76, 0x65, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49,
	0x44, 0x1a, 0x09, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x42, 0x4f, 0x4f, 0x4c, 0x22, 0x00, 0x12, 0x2c,
	0x0a, 0x0a, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12, 0x0a, 0x2e, 0x61,
	0x70, 0x69, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x0e, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x43,
	0x6d, 0x64, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22, 0x00, 0x30, 0x01, 0x12, 0x33, 0x0a, 0x0f,
	0x52, 0x75, 0x6e, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74, 0x4e, 0x6f, 0x57, 0x61, 0x69, 0x74, 0x12,
	0x15, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x63, 0x72, 0x69, 0x70, 0x74,
	0x4f, 0x6e, 0x48, 0x6f, 0x73, 0x74, 0x1a, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44, 0x22,
	0x00, 0x12, 0x34, 0x0a, 0x11, 0x44, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x41, 0x67, 0x65, 0x6e, 0x74,
	0x4e, 0x6f, 0x57, 0x61, 0x69, 0x74, 0x12, 0x14, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x54, 0x61, 0x73,
	0x6b, 0x44, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x1a, 0x07, 0x2e, 0x61,
	0x70, 0x69, 0x2e, 0x49, 0x44, 0x22, 0x00, 0x12, 0x33, 0x0a, 0x10, 0x52, 0x75, 0x6e, 0x43, 0x6d,
	0x64, 0x4c, 0x69, 0x6e, 0x65, 0x4e, 0x6f, 0x57, 0x61, 0x69, 0x74, 0x12, 0x14, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x4c, 0x69, 0x6e,
	0x65, 0x1a, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44, 0x22, 0x00, 0x12, 0x2c, 0x0a, 0x0d,
	0x53, 0x63, 0x70, 0x46, 0x69, 0x6c, 0x65, 0x4e, 0x6f, 0x57, 0x61, 0x69, 0x74, 0x12, 0x10, 0x2e,
	0x61, 0x70, 0x69, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x63, 0x70, 0x46, 0x69, 0x6c, 0x65, 0x1a,
	0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44, 0x22, 0x00, 0x12, 0x1e, 0x0a, 0x04, 0x57, 0x61,
	0x69, 0x74, 0x12, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44, 0x1a, 0x0b, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x00, 0x12, 0x23, 0x0a, 0x09, 0x47, 0x65,
	0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44,
	0x1a, 0x0b, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x00, 0x12,
	0x1d, 0x0a, 0x04, 0x53, 0x74, 0x6f, 0x70, 0x12, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44,
	0x1a, 0x0a, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x00, 0x12, 0x22,
	0x0a, 0x07, 0x52, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x12, 0x0a, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44, 0x22, 0x00,
	0x30, 0x01, 0x12, 0x33, 0x0a, 0x12, 0x53, 0x74, 0x61, 0x72, 0x74, 0x52, 0x65, 0x63, 0x75, 0x72,
	0x72, 0x69, 0x6e, 0x67, 0x54, 0x61, 0x73, 0x6b, 0x12, 0x12, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x54,
	0x61, 0x73, 0x6b, 0x52, 0x65, 0x63, 0x75, 0x72, 0x72, 0x69, 0x6e, 0x67, 0x1a, 0x07, 0x2e, 0x61,
	0x70, 0x69, 0x2e, 0x49, 0x44, 0x22, 0x00, 0x12, 0x33, 0x0a, 0x0a, 0x41, 0x63, 0x63, 0x65, 0x73,
	0x73, 0x48, 0x74, 0x74, 0x70, 0x12, 0x10, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x48, 0x74, 0x74, 0x70,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x11, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x48, 0x74,
	0x74, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x32, 0x0a, 0x14,
	0x41, 0x64, 0x64, 0x50, 0x6c, 0x61, 0x6e, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x43, 0x6c, 0x75,
	0x73, 0x74, 0x65, 0x72, 0x12, 0x0d, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x54, 0x6f, 0x6d, 0x6c, 0x43,
	0x6f, 0x6e, 0x66, 0x1a, 0x09, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x42, 0x4f, 0x4f, 0x4c, 0x22, 0x00,
	0x12, 0x2f, 0x0a, 0x17, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x50, 0x6c, 0x61, 0x6e, 0x56, 0x65,
	0x72, 0x69, 0x66, 0x79, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x12, 0x07, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x49, 0x44, 0x1a, 0x09, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x42, 0x4f, 0x4f, 0x4c, 0x22,
	0x00, 0x12, 0x3f, 0x0a, 0x1a, 0x52, 0x75, 0x6e, 0x54, 0x61, 0x73, 0x6b, 0x56, 0x65, 0x72, 0x69,
	0x66, 0x79, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x4e, 0x6f, 0x57, 0x61, 0x69, 0x74, 0x12,
	0x16, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79,
	0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x1a, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44,
	0x22, 0x00, 0x12, 0x2f, 0x0a, 0x13, 0x45, 0x6e, 0x73, 0x75, 0x72, 0x65, 0x49, 0x43, 0x53, 0x45,
	0x42, 0x44, 0x41, 0x4e, 0x6f, 0x57, 0x61, 0x69, 0x74, 0x12, 0x0d, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x54, 0x6f, 0x6d, 0x6c, 0x43, 0x6f, 0x6e, 0x66, 0x1a, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49,
	0x44, 0x22, 0x00, 0x12, 0x31, 0x0a, 0x11, 0x52, 0x75, 0x6e, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c,
	0x6f, 0x77, 0x4e, 0x6f, 0x57, 0x61, 0x69, 0x74, 0x12, 0x11, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x54,
	0x61, 0x73, 0x6b, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x1a, 0x07, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x49, 0x44, 0x22, 0x00, 0x12, 0x25, 0x0a, 0x0d, 0x50, 0x61, 0x75, 0x73, 0x65, 0x57,
	0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x12, 0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44,
	0x1a, 0x09, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x42, 0x4f, 0x4f, 0x4c, 0x22, 0x00, 0x12, 0x26, 0x0a,
	0x0e, 0x52, 0x65, 0x73, 0x75, 0x6d, 0x65, 0x57, 0x6f, 0x72, 0x6b, 0x46, 0x6c, 0x6f, 0x77, 0x12,
	0x07, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x44, 0x1a, 0x09, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x42,
	0x4f, 0x4f, 0x4c, 0x22, 0x00, 0x12, 0x34, 0x0a, 0x11, 0x57, 0x72, 0x69, 0x74, 0x65, 0x57, 0x46,
	0x42, 0x6c, 0x61, 0x63, 0x6b, 0x42, 0x6f, 0x61, 0x72, 0x64, 0x12, 0x12, 0x2e, 0x61, 0x70, 0x69,
	0x2e, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x42, 0x6f, 0x61, 0x72, 0x64, 0x4b, 0x56, 0x73, 0x1a, 0x09,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x42, 0x4f, 0x4f, 0x4c, 0x22, 0x00, 0x62, 0x06, 0x70, 0x72, 0x6f,
	0x74, 0x6f, 0x33,
}

var (
	file_api_proto_rawDescOnce sync.Once
	file_api_proto_rawDescData = file_api_proto_rawDesc
)

func file_api_proto_rawDescGZIP() []byte {
	file_api_proto_rawDescOnce.Do(func() {
		file_api_proto_rawDescData = protoimpl.X.CompressGZIP(file_api_proto_rawDescData)
	})
	return file_api_proto_rawDescData
}

var file_api_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_api_proto_msgTypes = make([]protoimpl.MessageInfo, 28)
var file_api_proto_goTypes = []interface{}{
	(TASKTYPE)(0),                // 0: api.TASKTYPE
	(COPYDIRECTION)(0),           // 1: api.COPYDIRECTION
	(STATE)(0),                   // 2: api.STATE
	(RETURNLINEMSGTYPE)(0),       // 3: api.RETURNLINEMSGTYPE
	(HTTPMETHOD)(0),              // 4: api.HTTPMETHOD
	(*TaskDeployAgent)(nil),      // 5: api.TaskDeployAgent
	(*TaskCommandLine)(nil),      // 6: api.TaskCommandLine
	(*CmdScript)(nil),            // 7: api.CmdScript
	(*TaskScriptOnHost)(nil),     // 8: api.TaskScriptOnHost
	(*TaskScpFile)(nil),          // 9: api.TaskScpFile
	(*Empty)(nil),                // 10: api.Empty
	(*Status)(nil),               // 11: api.Status
	(*PushServer)(nil),           // 12: api.PushServer
	(*BOOL)(nil),                 // 13: api.BOOL
	(*ID)(nil),                   // 14: api.ID
	(*CmdReturnLine)(nil),        // 15: api.CmdReturnLine
	(*TaskRecurring)(nil),        // 16: api.TaskRecurring
	(*TomlConf)(nil),             // 17: api.TomlConf
	(*TaskVerifyCluster)(nil),    // 18: api.TaskVerifyCluster
	(*KV)(nil),                   // 19: api.KV
	(*HttpRequest)(nil),          // 20: api.HttpRequest
	(*HttpResponse)(nil),         // 21: api.HttpResponse
	(*WorkFlowSchema)(nil),       // 22: api.WorkFlowSchema
	(*TaskWorkFlow)(nil),         // 23: api.TaskWorkFlow
	(*BlackBoardKVs)(nil),        // 24: api.BlackBoardKVs
	(*WorkFlowSchema_BNode)(nil), // 25: api.WorkFlowSchema.BNode
	(*WorkFlowSchema_WNode)(nil), // 26: api.WorkFlowSchema.WNode
	(*WorkFlowSchema_ENode)(nil), // 27: api.WorkFlowSchema.ENode
	nil,                          // 28: api.WorkFlowSchema.BNode.OutKVsEntry
	nil,                          // 29: api.WorkFlowSchema.WNode.OutKVsEntry
	nil,                          // 30: api.WorkFlowSchema.WNode.FailedKVsEntry
	nil,                          // 31: api.TaskWorkFlow.OverrideHalfWayKVsEntry
	nil,                          // 32: api.BlackBoardKVs.KVsEntry
}
var file_api_proto_depIdxs = []int32{
	1,  // 0: api.TaskScpFile.CopyDirection:type_name -> api.COPYDIRECTION
	2,  // 1: api.Status.State:type_name -> api.STATE
	3,  // 2: api.CmdReturnLine.Type:type_name -> api.RETURNLINEMSGTYPE
	4,  // 3: api.HttpRequest.Method:type_name -> api.HTTPMETHOD
	19, // 4: api.HttpRequest.Header:type_name -> api.KV
	19, // 5: api.HttpResponse.Header:type_name -> api.KV
	25, // 6: api.WorkFlowSchema.BeginNode:type_name -> api.WorkFlowSchema.BNode
	26, // 7: api.WorkFlowSchema.WorkerNodes:type_name -> api.WorkFlowSchema.WNode
	27, // 8: api.WorkFlowSchema.EndNode:type_name -> api.WorkFlowSchema.ENode
	22, // 9: api.TaskWorkFlow.Schema:type_name -> api.WorkFlowSchema
	31, // 10: api.TaskWorkFlow.OverrideHalfWayKVs:type_name -> api.TaskWorkFlow.OverrideHalfWayKVsEntry
	14, // 11: api.BlackBoardKVs.TWFID:type_name -> api.ID
	32, // 12: api.BlackBoardKVs.KVs:type_name -> api.BlackBoardKVs.KVsEntry
	28, // 13: api.WorkFlowSchema.BNode.OutKVs:type_name -> api.WorkFlowSchema.BNode.OutKVsEntry
	6,  // 14: api.WorkFlowSchema.WNode.NodeTask:type_name -> api.TaskCommandLine
	11, // 15: api.WorkFlowSchema.WNode.Status:type_name -> api.Status
	29, // 16: api.WorkFlowSchema.WNode.OutKVs:type_name -> api.WorkFlowSchema.WNode.OutKVsEntry
	30, // 17: api.WorkFlowSchema.WNode.FailedKVs:type_name -> api.WorkFlowSchema.WNode.FailedKVsEntry
	11, // 18: api.WorkFlowSchema.WNode.ReEnterHistory:type_name -> api.Status
	2,  // 19: api.WorkFlowSchema.ENode.State:type_name -> api.STATE
	12, // 20: api.CMDSvc.AddPushServer:input_type -> api.PushServer
	14, // 21: api.CMDSvc.RemovePushServer:input_type -> api.ID
	10, // 22: api.CMDSvc.ListPushServer:input_type -> api.Empty
	7,  // 23: api.CMDSvc.AddScript:input_type -> api.CmdScript
	14, // 24: api.CMDSvc.RemoveScript:input_type -> api.ID
	10, // 25: api.CMDSvc.ListScript:input_type -> api.Empty
	8,  // 26: api.CMDSvc.RunScriptNoWait:input_type -> api.TaskScriptOnHost
	5,  // 27: api.CMDSvc.DeployAgentNoWait:input_type -> api.TaskDeployAgent
	6,  // 28: api.CMDSvc.RunCmdLineNoWait:input_type -> api.TaskCommandLine
	9,  // 29: api.CMDSvc.ScpFileNoWait:input_type -> api.TaskScpFile
	14, // 30: api.CMDSvc.Wait:input_type -> api.ID
	14, // 31: api.CMDSvc.GetStatus:input_type -> api.ID
	14, // 32: api.CMDSvc.Stop:input_type -> api.ID
	10, // 33: api.CMDSvc.Running:input_type -> api.Empty
	16, // 34: api.CMDSvc.StartRecurringTask:input_type -> api.TaskRecurring
	20, // 35: api.CMDSvc.AccessHttp:input_type -> api.HttpRequest
	17, // 36: api.CMDSvc.AddPlanVerifyCluster:input_type -> api.TomlConf
	14, // 37: api.CMDSvc.RemovePlanVerifyCluster:input_type -> api.ID
	18, // 38: api.CMDSvc.RunTaskVerifyClusterNoWait:input_type -> api.TaskVerifyCluster
	17, // 39: api.CMDSvc.EnsureICSEBDANoWait:input_type -> api.TomlConf
	23, // 40: api.CMDSvc.RunWorkFlowNoWait:input_type -> api.TaskWorkFlow
	14, // 41: api.CMDSvc.PauseWorkFlow:input_type -> api.ID
	14, // 42: api.CMDSvc.ResumeWorkFlow:input_type -> api.ID
	24, // 43: api.CMDSvc.WriteWFBlackBoard:input_type -> api.BlackBoardKVs
	13, // 44: api.CMDSvc.AddPushServer:output_type -> api.BOOL
	13, // 45: api.CMDSvc.RemovePushServer:output_type -> api.BOOL
	12, // 46: api.CMDSvc.ListPushServer:output_type -> api.PushServer
	13, // 47: api.CMDSvc.AddScript:output_type -> api.BOOL
	13, // 48: api.CMDSvc.RemoveScript:output_type -> api.BOOL
	7,  // 49: api.CMDSvc.ListScript:output_type -> api.CmdScript
	14, // 50: api.CMDSvc.RunScriptNoWait:output_type -> api.ID
	14, // 51: api.CMDSvc.DeployAgentNoWait:output_type -> api.ID
	14, // 52: api.CMDSvc.RunCmdLineNoWait:output_type -> api.ID
	14, // 53: api.CMDSvc.ScpFileNoWait:output_type -> api.ID
	11, // 54: api.CMDSvc.Wait:output_type -> api.Status
	11, // 55: api.CMDSvc.GetStatus:output_type -> api.Status
	10, // 56: api.CMDSvc.Stop:output_type -> api.Empty
	14, // 57: api.CMDSvc.Running:output_type -> api.ID
	14, // 58: api.CMDSvc.StartRecurringTask:output_type -> api.ID
	21, // 59: api.CMDSvc.AccessHttp:output_type -> api.HttpResponse
	13, // 60: api.CMDSvc.AddPlanVerifyCluster:output_type -> api.BOOL
	13, // 61: api.CMDSvc.RemovePlanVerifyCluster:output_type -> api.BOOL
	14, // 62: api.CMDSvc.RunTaskVerifyClusterNoWait:output_type -> api.ID
	14, // 63: api.CMDSvc.EnsureICSEBDANoWait:output_type -> api.ID
	14, // 64: api.CMDSvc.RunWorkFlowNoWait:output_type -> api.ID
	13, // 65: api.CMDSvc.PauseWorkFlow:output_type -> api.BOOL
	13, // 66: api.CMDSvc.ResumeWorkFlow:output_type -> api.BOOL
	13, // 67: api.CMDSvc.WriteWFBlackBoard:output_type -> api.BOOL
	44, // [44:68] is the sub-list for method output_type
	20, // [20:44] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_api_proto_init() }
func file_api_proto_init() {
	if File_api_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_api_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TaskDeployAgent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TaskCommandLine); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CmdScript); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TaskScriptOnHost); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TaskScpFile); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Empty); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Status); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PushServer); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BOOL); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ID); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CmdReturnLine); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TaskRecurring); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TomlConf); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TaskVerifyCluster); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*KV); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HttpRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HttpResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WorkFlowSchema); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TaskWorkFlow); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BlackBoardKVs); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WorkFlowSchema_BNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WorkFlowSchema_WNode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_api_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*WorkFlowSchema_ENode); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_api_proto_rawDesc,
			NumEnums:      5,
			NumMessages:   28,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_api_proto_goTypes,
		DependencyIndexes: file_api_proto_depIdxs,
		EnumInfos:         file_api_proto_enumTypes,
		MessageInfos:      file_api_proto_msgTypes,
	}.Build()
	File_api_proto = out.File
	file_api_proto_rawDesc = nil
	file_api_proto_goTypes = nil
	file_api_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// CMDSvcClient is the client API for CMDSvc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CMDSvcClient interface {
	AddPushServer(ctx context.Context, in *PushServer, opts ...grpc.CallOption) (*BOOL, error)
	RemovePushServer(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error)
	ListPushServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CMDSvc_ListPushServerClient, error)
	AddScript(ctx context.Context, in *CmdScript, opts ...grpc.CallOption) (*BOOL, error)
	RemoveScript(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error)
	ListScript(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CMDSvc_ListScriptClient, error)
	//compare md5,  -1 -- Script non-existed , -2 -- md5 error
	RunScriptNoWait(ctx context.Context, in *TaskScriptOnHost, opts ...grpc.CallOption) (*ID, error)
	DeployAgentNoWait(ctx context.Context, in *TaskDeployAgent, opts ...grpc.CallOption) (*ID, error)
	// Start a command and immediately return its ID.
	RunCmdLineNoWait(ctx context.Context, in *TaskCommandLine, opts ...grpc.CallOption) (*ID, error)
	ScpFileNoWait(ctx context.Context, in *TaskScpFile, opts ...grpc.CallOption) (*ID, error)
	// Wait for a command to complete or be stopped, reap it, and return its final status.
	Wait(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Status, error)
	// Get the status of a command if it hasn't been reaped by calling Wait or Stop.
	GetStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Status, error)
	// Stop then reap a command by sending it a SIGTERM signal.
	Stop(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error)
	// Return a list of all running (not reaped) commands by ID.
	Running(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CMDSvc_RunningClient, error)
	StartRecurringTask(ctx context.Context, in *TaskRecurring, opts ...grpc.CallOption) (*ID, error)
	// AccessHttp -- a block function with timeout
	AccessHttp(ctx context.Context, in *HttpRequest, opts ...grpc.CallOption) (*HttpResponse, error)
	// VerifyCluster
	//AddPlanVerifyCluster -- add toml plan. return true if configs in plan verified.
	AddPlanVerifyCluster(ctx context.Context, in *TomlConf, opts ...grpc.CallOption) (*BOOL, error)
	//RemovePlanVerifyCluster -- input plan ID
	RemovePlanVerifyCluster(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error)
	//RunTaskVerifyClusterNoWait -- non-block func.
	//using GetStatus to get on-way status, or Wait to get final status.
	//or Stop to interrupt task.
	//input plan ID and push tags, return task ID
	RunTaskVerifyClusterNoWait(ctx context.Context, in *TaskVerifyCluster, opts ...grpc.CallOption) (*ID, error)
	// EnsureICSEBDA -- unblock function, use Wait or pushserver to get final results.
	// all configs details shoule be define a toml file, then load content
	// and send as a only parameter. the sample of toml file is in
	// bin/tools/batchdeployagents/
	EnsureICSEBDANoWait(ctx context.Context, in *TomlConf, opts ...grpc.CallOption) (*ID, error)
	// unblock function. Please use Wait() or GetStatus() as other type tasks.
	RunWorkFlowNoWait(ctx context.Context, in *TaskWorkFlow, opts ...grpc.CallOption) (*ID, error)
	//two unblock functions to pause and resume triggers of
	//all waiting nodes of a workflow
	PauseWorkFlow(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error)
	ResumeWorkFlow(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error)
	//WriteWFBlackBoard -- write KVs to BlackBoard of a running TaskWorkFlow
	//to adjust flow
	WriteWFBlackBoard(ctx context.Context, in *BlackBoardKVs, opts ...grpc.CallOption) (*BOOL, error)
}

type cMDSvcClient struct {
	cc grpc.ClientConnInterface
}

func NewCMDSvcClient(cc grpc.ClientConnInterface) CMDSvcClient {
	return &cMDSvcClient{cc}
}

func (c *cMDSvcClient) AddPushServer(ctx context.Context, in *PushServer, opts ...grpc.CallOption) (*BOOL, error) {
	out := new(BOOL)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/AddPushServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) RemovePushServer(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error) {
	out := new(BOOL)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/RemovePushServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) ListPushServer(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CMDSvc_ListPushServerClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CMDSvc_serviceDesc.Streams[0], "/api.CMDSvc/ListPushServer", opts...)
	if err != nil {
		return nil, err
	}
	x := &cMDSvcListPushServerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CMDSvc_ListPushServerClient interface {
	Recv() (*PushServer, error)
	grpc.ClientStream
}

type cMDSvcListPushServerClient struct {
	grpc.ClientStream
}

func (x *cMDSvcListPushServerClient) Recv() (*PushServer, error) {
	m := new(PushServer)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cMDSvcClient) AddScript(ctx context.Context, in *CmdScript, opts ...grpc.CallOption) (*BOOL, error) {
	out := new(BOOL)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/AddScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) RemoveScript(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error) {
	out := new(BOOL)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/RemoveScript", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) ListScript(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CMDSvc_ListScriptClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CMDSvc_serviceDesc.Streams[1], "/api.CMDSvc/ListScript", opts...)
	if err != nil {
		return nil, err
	}
	x := &cMDSvcListScriptClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CMDSvc_ListScriptClient interface {
	Recv() (*CmdScript, error)
	grpc.ClientStream
}

type cMDSvcListScriptClient struct {
	grpc.ClientStream
}

func (x *cMDSvcListScriptClient) Recv() (*CmdScript, error) {
	m := new(CmdScript)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cMDSvcClient) RunScriptNoWait(ctx context.Context, in *TaskScriptOnHost, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/RunScriptNoWait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) DeployAgentNoWait(ctx context.Context, in *TaskDeployAgent, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/DeployAgentNoWait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) RunCmdLineNoWait(ctx context.Context, in *TaskCommandLine, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/RunCmdLineNoWait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) ScpFileNoWait(ctx context.Context, in *TaskScpFile, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/ScpFileNoWait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) Wait(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/Wait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) GetStatus(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/GetStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) Stop(ctx context.Context, in *ID, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) Running(ctx context.Context, in *Empty, opts ...grpc.CallOption) (CMDSvc_RunningClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CMDSvc_serviceDesc.Streams[2], "/api.CMDSvc/Running", opts...)
	if err != nil {
		return nil, err
	}
	x := &cMDSvcRunningClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CMDSvc_RunningClient interface {
	Recv() (*ID, error)
	grpc.ClientStream
}

type cMDSvcRunningClient struct {
	grpc.ClientStream
}

func (x *cMDSvcRunningClient) Recv() (*ID, error) {
	m := new(ID)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cMDSvcClient) StartRecurringTask(ctx context.Context, in *TaskRecurring, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/StartRecurringTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) AccessHttp(ctx context.Context, in *HttpRequest, opts ...grpc.CallOption) (*HttpResponse, error) {
	out := new(HttpResponse)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/AccessHttp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) AddPlanVerifyCluster(ctx context.Context, in *TomlConf, opts ...grpc.CallOption) (*BOOL, error) {
	out := new(BOOL)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/AddPlanVerifyCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) RemovePlanVerifyCluster(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error) {
	out := new(BOOL)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/RemovePlanVerifyCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) RunTaskVerifyClusterNoWait(ctx context.Context, in *TaskVerifyCluster, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/RunTaskVerifyClusterNoWait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) EnsureICSEBDANoWait(ctx context.Context, in *TomlConf, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/EnsureICSEBDANoWait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) RunWorkFlowNoWait(ctx context.Context, in *TaskWorkFlow, opts ...grpc.CallOption) (*ID, error) {
	out := new(ID)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/RunWorkFlowNoWait", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) PauseWorkFlow(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error) {
	out := new(BOOL)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/PauseWorkFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) ResumeWorkFlow(ctx context.Context, in *ID, opts ...grpc.CallOption) (*BOOL, error) {
	out := new(BOOL)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/ResumeWorkFlow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cMDSvcClient) WriteWFBlackBoard(ctx context.Context, in *BlackBoardKVs, opts ...grpc.CallOption) (*BOOL, error) {
	out := new(BOOL)
	err := c.cc.Invoke(ctx, "/api.CMDSvc/WriteWFBlackBoard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CMDSvcServer is the server API for CMDSvc service.
type CMDSvcServer interface {
	AddPushServer(context.Context, *PushServer) (*BOOL, error)
	RemovePushServer(context.Context, *ID) (*BOOL, error)
	ListPushServer(*Empty, CMDSvc_ListPushServerServer) error
	AddScript(context.Context, *CmdScript) (*BOOL, error)
	RemoveScript(context.Context, *ID) (*BOOL, error)
	ListScript(*Empty, CMDSvc_ListScriptServer) error
	//compare md5,  -1 -- Script non-existed , -2 -- md5 error
	RunScriptNoWait(context.Context, *TaskScriptOnHost) (*ID, error)
	DeployAgentNoWait(context.Context, *TaskDeployAgent) (*ID, error)
	// Start a command and immediately return its ID.
	RunCmdLineNoWait(context.Context, *TaskCommandLine) (*ID, error)
	ScpFileNoWait(context.Context, *TaskScpFile) (*ID, error)
	// Wait for a command to complete or be stopped, reap it, and return its final status.
	Wait(context.Context, *ID) (*Status, error)
	// Get the status of a command if it hasn't been reaped by calling Wait or Stop.
	GetStatus(context.Context, *ID) (*Status, error)
	// Stop then reap a command by sending it a SIGTERM signal.
	Stop(context.Context, *ID) (*Empty, error)
	// Return a list of all running (not reaped) commands by ID.
	Running(*Empty, CMDSvc_RunningServer) error
	StartRecurringTask(context.Context, *TaskRecurring) (*ID, error)
	// AccessHttp -- a block function with timeout
	AccessHttp(context.Context, *HttpRequest) (*HttpResponse, error)
	// VerifyCluster
	//AddPlanVerifyCluster -- add toml plan. return true if configs in plan verified.
	AddPlanVerifyCluster(context.Context, *TomlConf) (*BOOL, error)
	//RemovePlanVerifyCluster -- input plan ID
	RemovePlanVerifyCluster(context.Context, *ID) (*BOOL, error)
	//RunTaskVerifyClusterNoWait -- non-block func.
	//using GetStatus to get on-way status, or Wait to get final status.
	//or Stop to interrupt task.
	//input plan ID and push tags, return task ID
	RunTaskVerifyClusterNoWait(context.Context, *TaskVerifyCluster) (*ID, error)
	// EnsureICSEBDA -- unblock function, use Wait or pushserver to get final results.
	// all configs details shoule be define a toml file, then load content
	// and send as a only parameter. the sample of toml file is in
	// bin/tools/batchdeployagents/
	EnsureICSEBDANoWait(context.Context, *TomlConf) (*ID, error)
	// unblock function. Please use Wait() or GetStatus() as other type tasks.
	RunWorkFlowNoWait(context.Context, *TaskWorkFlow) (*ID, error)
	//two unblock functions to pause and resume triggers of
	//all waiting nodes of a workflow
	PauseWorkFlow(context.Context, *ID) (*BOOL, error)
	ResumeWorkFlow(context.Context, *ID) (*BOOL, error)
	//WriteWFBlackBoard -- write KVs to BlackBoard of a running TaskWorkFlow
	//to adjust flow
	WriteWFBlackBoard(context.Context, *BlackBoardKVs) (*BOOL, error)
}

// UnimplementedCMDSvcServer can be embedded to have forward compatible implementations.
type UnimplementedCMDSvcServer struct {
}

func (*UnimplementedCMDSvcServer) AddPushServer(context.Context, *PushServer) (*BOOL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPushServer not implemented")
}
func (*UnimplementedCMDSvcServer) RemovePushServer(context.Context, *ID) (*BOOL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePushServer not implemented")
}
func (*UnimplementedCMDSvcServer) ListPushServer(*Empty, CMDSvc_ListPushServerServer) error {
	return status.Errorf(codes.Unimplemented, "method ListPushServer not implemented")
}
func (*UnimplementedCMDSvcServer) AddScript(context.Context, *CmdScript) (*BOOL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddScript not implemented")
}
func (*UnimplementedCMDSvcServer) RemoveScript(context.Context, *ID) (*BOOL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveScript not implemented")
}
func (*UnimplementedCMDSvcServer) ListScript(*Empty, CMDSvc_ListScriptServer) error {
	return status.Errorf(codes.Unimplemented, "method ListScript not implemented")
}
func (*UnimplementedCMDSvcServer) RunScriptNoWait(context.Context, *TaskScriptOnHost) (*ID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunScriptNoWait not implemented")
}
func (*UnimplementedCMDSvcServer) DeployAgentNoWait(context.Context, *TaskDeployAgent) (*ID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeployAgentNoWait not implemented")
}
func (*UnimplementedCMDSvcServer) RunCmdLineNoWait(context.Context, *TaskCommandLine) (*ID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCmdLineNoWait not implemented")
}
func (*UnimplementedCMDSvcServer) ScpFileNoWait(context.Context, *TaskScpFile) (*ID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScpFileNoWait not implemented")
}
func (*UnimplementedCMDSvcServer) Wait(context.Context, *ID) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Wait not implemented")
}
func (*UnimplementedCMDSvcServer) GetStatus(context.Context, *ID) (*Status, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (*UnimplementedCMDSvcServer) Stop(context.Context, *ID) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (*UnimplementedCMDSvcServer) Running(*Empty, CMDSvc_RunningServer) error {
	return status.Errorf(codes.Unimplemented, "method Running not implemented")
}
func (*UnimplementedCMDSvcServer) StartRecurringTask(context.Context, *TaskRecurring) (*ID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRecurringTask not implemented")
}
func (*UnimplementedCMDSvcServer) AccessHttp(context.Context, *HttpRequest) (*HttpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccessHttp not implemented")
}
func (*UnimplementedCMDSvcServer) AddPlanVerifyCluster(context.Context, *TomlConf) (*BOOL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPlanVerifyCluster not implemented")
}
func (*UnimplementedCMDSvcServer) RemovePlanVerifyCluster(context.Context, *ID) (*BOOL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePlanVerifyCluster not implemented")
}
func (*UnimplementedCMDSvcServer) RunTaskVerifyClusterNoWait(context.Context, *TaskVerifyCluster) (*ID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunTaskVerifyClusterNoWait not implemented")
}
func (*UnimplementedCMDSvcServer) EnsureICSEBDANoWait(context.Context, *TomlConf) (*ID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnsureICSEBDANoWait not implemented")
}
func (*UnimplementedCMDSvcServer) RunWorkFlowNoWait(context.Context, *TaskWorkFlow) (*ID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunWorkFlowNoWait not implemented")
}
func (*UnimplementedCMDSvcServer) PauseWorkFlow(context.Context, *ID) (*BOOL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PauseWorkFlow not implemented")
}
func (*UnimplementedCMDSvcServer) ResumeWorkFlow(context.Context, *ID) (*BOOL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeWorkFlow not implemented")
}
func (*UnimplementedCMDSvcServer) WriteWFBlackBoard(context.Context, *BlackBoardKVs) (*BOOL, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteWFBlackBoard not implemented")
}

func RegisterCMDSvcServer(s *grpc.Server, srv CMDSvcServer) {
	s.RegisterService(&_CMDSvc_serviceDesc, srv)
}

func _CMDSvc_AddPushServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushServer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).AddPushServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/AddPushServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).AddPushServer(ctx, req.(*PushServer))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_RemovePushServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).RemovePushServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/RemovePushServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).RemovePushServer(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_ListPushServer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CMDSvcServer).ListPushServer(m, &cMDSvcListPushServerServer{stream})
}

type CMDSvc_ListPushServerServer interface {
	Send(*PushServer) error
	grpc.ServerStream
}

type cMDSvcListPushServerServer struct {
	grpc.ServerStream
}

func (x *cMDSvcListPushServerServer) Send(m *PushServer) error {
	return x.ServerStream.SendMsg(m)
}

func _CMDSvc_AddScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CmdScript)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).AddScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/AddScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).AddScript(ctx, req.(*CmdScript))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_RemoveScript_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).RemoveScript(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/RemoveScript",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).RemoveScript(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_ListScript_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CMDSvcServer).ListScript(m, &cMDSvcListScriptServer{stream})
}

type CMDSvc_ListScriptServer interface {
	Send(*CmdScript) error
	grpc.ServerStream
}

type cMDSvcListScriptServer struct {
	grpc.ServerStream
}

func (x *cMDSvcListScriptServer) Send(m *CmdScript) error {
	return x.ServerStream.SendMsg(m)
}

func _CMDSvc_RunScriptNoWait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskScriptOnHost)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).RunScriptNoWait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/RunScriptNoWait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).RunScriptNoWait(ctx, req.(*TaskScriptOnHost))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_DeployAgentNoWait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskDeployAgent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).DeployAgentNoWait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/DeployAgentNoWait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).DeployAgentNoWait(ctx, req.(*TaskDeployAgent))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_RunCmdLineNoWait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskCommandLine)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).RunCmdLineNoWait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/RunCmdLineNoWait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).RunCmdLineNoWait(ctx, req.(*TaskCommandLine))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_ScpFileNoWait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskScpFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).ScpFileNoWait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/ScpFileNoWait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).ScpFileNoWait(ctx, req.(*TaskScpFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_Wait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).Wait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/Wait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).Wait(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/GetStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).GetStatus(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).Stop(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_Running_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CMDSvcServer).Running(m, &cMDSvcRunningServer{stream})
}

type CMDSvc_RunningServer interface {
	Send(*ID) error
	grpc.ServerStream
}

type cMDSvcRunningServer struct {
	grpc.ServerStream
}

func (x *cMDSvcRunningServer) Send(m *ID) error {
	return x.ServerStream.SendMsg(m)
}

func _CMDSvc_StartRecurringTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskRecurring)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).StartRecurringTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/StartRecurringTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).StartRecurringTask(ctx, req.(*TaskRecurring))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_AccessHttp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HttpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).AccessHttp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/AccessHttp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).AccessHttp(ctx, req.(*HttpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_AddPlanVerifyCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TomlConf)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).AddPlanVerifyCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/AddPlanVerifyCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).AddPlanVerifyCluster(ctx, req.(*TomlConf))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_RemovePlanVerifyCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).RemovePlanVerifyCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/RemovePlanVerifyCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).RemovePlanVerifyCluster(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_RunTaskVerifyClusterNoWait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskVerifyCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).RunTaskVerifyClusterNoWait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/RunTaskVerifyClusterNoWait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).RunTaskVerifyClusterNoWait(ctx, req.(*TaskVerifyCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_EnsureICSEBDANoWait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TomlConf)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).EnsureICSEBDANoWait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/EnsureICSEBDANoWait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).EnsureICSEBDANoWait(ctx, req.(*TomlConf))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_RunWorkFlowNoWait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TaskWorkFlow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).RunWorkFlowNoWait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/RunWorkFlowNoWait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).RunWorkFlowNoWait(ctx, req.(*TaskWorkFlow))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_PauseWorkFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).PauseWorkFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/PauseWorkFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).PauseWorkFlow(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_ResumeWorkFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).ResumeWorkFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/ResumeWorkFlow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).ResumeWorkFlow(ctx, req.(*ID))
	}
	return interceptor(ctx, in, info, handler)
}

func _CMDSvc_WriteWFBlackBoard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlackBoardKVs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CMDSvcServer).WriteWFBlackBoard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CMDSvc/WriteWFBlackBoard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CMDSvcServer).WriteWFBlackBoard(ctx, req.(*BlackBoardKVs))
	}
	return interceptor(ctx, in, info, handler)
}

var _CMDSvc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.CMDSvc",
	HandlerType: (*CMDSvcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddPushServer",
			Handler:    _CMDSvc_AddPushServer_Handler,
		},
		{
			MethodName: "RemovePushServer",
			Handler:    _CMDSvc_RemovePushServer_Handler,
		},
		{
			MethodName: "AddScript",
			Handler:    _CMDSvc_AddScript_Handler,
		},
		{
			MethodName: "RemoveScript",
			Handler:    _CMDSvc_RemoveScript_Handler,
		},
		{
			MethodName: "RunScriptNoWait",
			Handler:    _CMDSvc_RunScriptNoWait_Handler,
		},
		{
			MethodName: "DeployAgentNoWait",
			Handler:    _CMDSvc_DeployAgentNoWait_Handler,
		},
		{
			MethodName: "RunCmdLineNoWait",
			Handler:    _CMDSvc_RunCmdLineNoWait_Handler,
		},
		{
			MethodName: "ScpFileNoWait",
			Handler:    _CMDSvc_ScpFileNoWait_Handler,
		},
		{
			MethodName: "Wait",
			Handler:    _CMDSvc_Wait_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _CMDSvc_GetStatus_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _CMDSvc_Stop_Handler,
		},
		{
			MethodName: "StartRecurringTask",
			Handler:    _CMDSvc_StartRecurringTask_Handler,
		},
		{
			MethodName: "AccessHttp",
			Handler:    _CMDSvc_AccessHttp_Handler,
		},
		{
			MethodName: "AddPlanVerifyCluster",
			Handler:    _CMDSvc_AddPlanVerifyCluster_Handler,
		},
		{
			MethodName: "RemovePlanVerifyCluster",
			Handler:    _CMDSvc_RemovePlanVerifyCluster_Handler,
		},
		{
			MethodName: "RunTaskVerifyClusterNoWait",
			Handler:    _CMDSvc_RunTaskVerifyClusterNoWait_Handler,
		},
		{
			MethodName: "EnsureICSEBDANoWait",
			Handler:    _CMDSvc_EnsureICSEBDANoWait_Handler,
		},
		{
			MethodName: "RunWorkFlowNoWait",
			Handler:    _CMDSvc_RunWorkFlowNoWait_Handler,
		},
		{
			MethodName: "PauseWorkFlow",
			Handler:    _CMDSvc_PauseWorkFlow_Handler,
		},
		{
			MethodName: "ResumeWorkFlow",
			Handler:    _CMDSvc_ResumeWorkFlow_Handler,
		},
		{
			MethodName: "WriteWFBlackBoard",
			Handler:    _CMDSvc_WriteWFBlackBoard_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListPushServer",
			Handler:       _CMDSvc_ListPushServer_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListScript",
			Handler:       _CMDSvc_ListScript_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Running",
			Handler:       _CMDSvc_Running_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}
